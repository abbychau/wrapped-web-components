{"version":3,"file":"index.esm.min.js","sources":["../src/core/component.js","../src/core/html.js","../src/core/css.js","../src/core/define.js","../src/core/loader.js","../src/core/registry.js"],"sourcesContent":["/**\n * Base Component class that extends HTMLElement\n * Provides the foundation for creating web components with plain HTML, JS, and CSS\n */\n\nexport class Component extends HTMLElement {\n  constructor() {\n    super();\n\n    // Create shadow DOM only if explicitly requested\n    if (this.constructor.useShadow === true) {\n      this.attachShadow({ mode: 'open' });\n    }\n\n    // Store for component properties\n    this._props = {};\n\n    // Initialize component\n    this._initialize();\n  }\n\n  /**\n   * Initialize the component\n   * @private\n   */\n  _initialize() {\n    // Apply styles if defined\n    if (this.constructor.styles) {\n      this._applyStyles();\n    }\n\n    // Apply template if defined\n    if (this.constructor.template) {\n      this._applyTemplate();\n    }\n\n    // Call the component's init method if it exists\n    if (typeof this.init === 'function') {\n      this.init();\n    }\n  }\n\n  /**\n   * Apply styles to the component\n   * @private\n   */\n  _applyStyles() {\n    const styles = this.constructor.styles;\n\n    if (this.shadowRoot) {\n      // If using shadow DOM, add styles to the shadow root\n      const styleElement = document.createElement('style');\n      styleElement.textContent = styles;\n      this.shadowRoot.appendChild(styleElement);\n    } else {\n      // If not using shadow DOM, add scoped styles\n      const styleElement = document.createElement('style');\n\n      // Add a unique attribute to the component\n      const scopeAttr = `data-${this.tagName.toLowerCase()}-${Math.random().toString(36).substring(2, 8)}`;\n      this.setAttribute(scopeAttr, '');\n\n      // Process CSS to scope all selectors with the unique attribute\n      let scopedStyles = '';\n\n      // Split the CSS into rule blocks\n      const cssRules = styles.split('}');\n\n      for (let rule of cssRules) {\n        if (!rule.trim()) continue;\n\n        // Find the position of the opening brace\n        const braceIndex = rule.indexOf('{');\n        if (braceIndex === -1) continue;\n\n        // Extract selector and declarations\n        const selector = rule.substring(0, braceIndex).trim();\n        const declarations = rule.substring(braceIndex + 1).trim();\n\n        // Skip @-rules like @media, @keyframes, etc.\n        if (selector.startsWith('@')) {\n          scopedStyles += `${rule}}`;\n          continue;\n        }\n\n        // Add scope to each selector\n        const scopedSelector = selector\n          .split(',')\n          .map(s => `[${scopeAttr}] ${s.trim()}`)\n          .join(', ');\n\n        // Combine the scoped selector with the declarations\n        scopedStyles += `${scopedSelector} {${declarations}}`;\n      }\n\n      styleElement.textContent = scopedStyles;\n      document.head.appendChild(styleElement);\n    }\n  }\n\n  /**\n   * Apply template to the component\n   * @private\n   */\n  _applyTemplate() {\n    const template = this.constructor.template;\n\n    // Get the container (shadow root or the element itself)\n    const container = this.shadowRoot || this;\n\n    // If template is a function, call it with the component as context\n    if (typeof template === 'function') {\n      container.innerHTML = template.call(this);\n    } else {\n      container.innerHTML = template;\n    }\n\n    // Process any event bindings in the template\n    this._processEventBindings(container);\n  }\n\n  /**\n   * Process event bindings in the template\n   * @private\n   * @param {Element} container - The container element (shadow root or the element itself)\n   */\n  _processEventBindings(container) {\n    // Get all elements in the container\n    const allElements = container.querySelectorAll('*');\n\n    // Iterate through all elements to find those with data-event attributes\n    Array.from(allElements).forEach(element => {\n      // Get all attributes\n      const attributes = Array.from(element.attributes);\n\n      // Find event binding attributes\n      const eventAttrs = attributes.filter(attr => attr.name.startsWith('data-event-'));\n\n      eventAttrs.forEach(attr => {\n        // Extract event name and handler name\n        const eventName = attr.name.replace('data-event-', '');\n        const handlerName = attr.value;\n\n        // Check if the handler exists on the component\n        if (typeof this[handlerName] === 'function') {\n          // Add event listener\n          element.addEventListener(eventName, this[handlerName].bind(this));\n        } else {\n          console.warn(`Handler \"${handlerName}\" not found for event \"${eventName}\"`);\n        }\n\n        // Remove the attribute\n        element.removeAttribute(attr.name);\n      });\n    });\n  }\n\n  /**\n   * Called when the element is connected to the DOM\n   */\n  connectedCallback() {\n    if (typeof this.connected === 'function') {\n      this.connected();\n    }\n  }\n\n  /**\n   * Called when the element is disconnected from the DOM\n   */\n  disconnectedCallback() {\n    if (typeof this.disconnected === 'function') {\n      this.disconnected();\n    }\n  }\n\n  /**\n   * Called when an observed attribute changes\n   * @param {string} name - The name of the attribute\n   * @param {string} oldValue - The old value of the attribute\n   * @param {string} newValue - The new value of the attribute\n   */\n  attributeChangedCallback(name, oldValue, newValue) {\n    // Update the corresponding property\n    if (oldValue !== newValue) {\n      // Convert attribute name to property name (kebab-case to camelCase)\n      const propName = name.replace(/-([a-z])/g, (_, letter) => letter.toUpperCase());\n\n      // Update the property\n      this[propName] = this._parseAttributeValue(newValue);\n\n      // Call the attribute changed method if it exists\n      if (typeof this.attributeChanged === 'function') {\n        this.attributeChanged(name, oldValue, newValue);\n      }\n    }\n  }\n\n  /**\n   * Parse attribute value to the appropriate type\n   * @private\n   * @param {string} value - The attribute value\n   * @returns {*} - The parsed value\n   */\n  _parseAttributeValue(value) {\n    // If value is null or undefined, return it as is\n    if (value === null || value === undefined) {\n      return value;\n    }\n\n    // Try to parse as JSON\n    try {\n      return JSON.parse(value);\n    } catch (e) {\n      // If parsing fails, return the value as a string\n      return value;\n    }\n  }\n\n  /**\n   * Query an element that works with both Shadow DOM and Light DOM\n   * @param {string} selector - CSS selector to query\n   * @returns {Element|null} - The first element matching the selector or null\n   */\n  getElement(selector) {\n    return this.shadowRoot\n      ? this.shadowRoot.querySelector(selector)\n      : this.querySelector(selector);\n  }\n\n  /**\n   * Query all elements that work with both Shadow DOM and Light DOM\n   * @param {string} selector - CSS selector to query\n   * @returns {NodeList} - All elements matching the selector\n   */\n  getAllElements(selector) {\n    return this.shadowRoot\n      ? this.shadowRoot.querySelectorAll(selector)\n      : this.querySelectorAll(selector);\n  }\n\n  /**\n   * Update the component with new properties\n   * @param {Object} props - The properties to update\n   */\n  update(props = {}) {\n    // Update properties\n    Object.entries(props).forEach(([key, value]) => {\n      this[key] = value;\n    });\n\n    // Re-render the component\n    if (this.constructor.template) {\n      this._applyTemplate();\n    }\n  }\n}\n","/**\n * HTML templating utility\n * Allows for creating HTML templates with interpolation\n */\n\n/**\n * Creates an HTML template string with interpolation\n * @param {Array<string>} strings - The template string parts\n * @param {...*} values - The values to interpolate\n * @returns {string} - The processed HTML string\n */\nexport function html(strings, ...values) {\n  return strings.reduce((result, string, i) => {\n    const value = values[i] || '';\n    \n    // Process the value based on its type\n    let processedValue;\n    \n    if (value === null || value === undefined) {\n      processedValue = '';\n    } else if (typeof value === 'object' && value.isEventBinding) {\n      // Handle event binding\n      processedValue = `data-event-${value.eventName}=\"${value.handlerName}\"`;\n    } else if (Array.isArray(value)) {\n      // Join arrays\n      processedValue = value.join('');\n    } else {\n      // Convert to string and escape HTML\n      processedValue = escapeHTML(String(value));\n    }\n    \n    return result + string + processedValue;\n  }, '');\n}\n\n/**\n * Creates an event binding for use in templates\n * @param {string} eventName - The name of the event (e.g., 'click')\n * @param {string} handlerName - The name of the handler method on the component\n * @returns {Object} - An event binding object\n */\nhtml.event = function(eventName, handlerName) {\n  return {\n    isEventBinding: true,\n    eventName,\n    handlerName\n  };\n};\n\n/**\n * Escapes HTML special characters to prevent XSS\n * @param {string} str - The string to escape\n * @returns {string} - The escaped string\n */\nfunction escapeHTML(str) {\n  return str\n    .replace(/&/g, '&amp;')\n    .replace(/</g, '&lt;')\n    .replace(/>/g, '&gt;')\n    .replace(/\"/g, '&quot;')\n    .replace(/'/g, '&#039;');\n}\n","/**\n * CSS utility for creating component styles\n */\n\n/**\n * Creates a CSS string from template literals\n * @param {Array<string>} strings - The template string parts\n * @param {...*} values - The values to interpolate\n * @returns {string} - The processed CSS string\n */\nexport function css(strings, ...values) {\n  return strings.reduce((result, string, i) => {\n    const value = values[i] || '';\n    return result + string + value;\n  }, '');\n}\n","/**\n * Utility for defining custom elements\n */\n\nimport { Component } from './component.js';\n\n/**\n * Define a custom element\n * @param {string} tagName - The tag name for the custom element\n * @param {Object} options - The component options\n * @param {string|Function} [options.template] - The HTML template\n * @param {string} [options.styles] - The CSS styles\n * @param {boolean} [options.useShadow=false] - Whether to use Shadow DOM\n * @param {Array<string>} [options.observedAttributes=[]] - Attributes to observe\n * @param {Object} [options.methods={}] - Methods to add to the component\n * @param {Object} [options.properties={}] - Properties to add to the component\n * @returns {typeof Component} - The component class\n */\nexport function define(tagName, options = {}) {\n  // Create a new component class that extends the base Component\n  class CustomComponent extends Component {}\n\n  // Add static properties\n  CustomComponent.template = options.template || '';\n  CustomComponent.styles = options.styles || '';\n  CustomComponent.useShadow = options.useShadow === true;\n  CustomComponent.observedAttributes = options.observedAttributes || [];\n\n  // Add methods to the prototype\n  if (options.methods) {\n    Object.entries(options.methods).forEach(([name, method]) => {\n      CustomComponent.prototype[name] = method;\n    });\n  }\n\n  // Add property getters and setters\n  if (options.properties) {\n    Object.entries(options.properties).forEach(([name, config]) => {\n      // Define the property\n      Object.defineProperty(CustomComponent.prototype, name, {\n        get() {\n          return this._props[name] !== undefined ? this._props[name] : config.default;\n        },\n        set(value) {\n          const oldValue = this._props[name];\n          this._props[name] = value;\n\n          // Reflect to attribute if specified\n          if (config.reflect) {\n            const attrName = name.replace(/([A-Z])/g, '-$1').toLowerCase();\n\n            if (value === null || value === undefined) {\n              this.removeAttribute(attrName);\n            } else if (typeof value === 'boolean') {\n              if (value) {\n                this.setAttribute(attrName, '');\n              } else {\n                this.removeAttribute(attrName);\n              }\n            } else {\n              this.setAttribute(attrName, value);\n            }\n          }\n\n          // Call property changed callback if it exists\n          if (typeof this.propertyChanged === 'function' && oldValue !== value) {\n            this.propertyChanged(name, oldValue, value);\n          }\n        },\n        configurable: true,\n        enumerable: true\n      });\n\n      // Add to observed attributes if reflective\n      if (config.reflect && !CustomComponent.observedAttributes.includes(name)) {\n        const attrName = name.replace(/([A-Z])/g, '-$1').toLowerCase();\n        CustomComponent.observedAttributes.push(attrName);\n      }\n    });\n  }\n\n  // Define the custom element\n  customElements.define(tagName, CustomComponent);\n\n  return CustomComponent;\n}\n","/**\n * Component Loader\n * Loads and parses HTML component files\n */\n\n/**\n * Loads a component from an HTML file\n * @param {string} url - The URL of the HTML file\n * @returns {Promise<Object>} - The parsed component\n */\nexport async function loadComponent(url) {\n  try {\n    const response = await fetch(url);\n    \n    if (!response.ok) {\n      throw new Error(`Failed to load component from ${url}: ${response.statusText}`);\n    }\n    \n    const html = await response.text();\n    return parseComponent(html);\n  } catch (error) {\n    console.error(`Error loading component: ${error.message}`);\n    throw error;\n  }\n}\n\n/**\n * Parses a component from HTML string\n * @param {string} html - The HTML string\n * @returns {Object} - The parsed component\n */\nexport function parseComponent(html) {\n  // Create a temporary document to parse the HTML\n  const parser = new DOMParser();\n  const doc = parser.parseFromString(html, 'text/html');\n  \n  // Extract template\n  const templateElement = doc.querySelector('template');\n  const template = templateElement ? templateElement.innerHTML.trim() : '';\n  \n  // Extract style\n  const styleElement = doc.querySelector('style');\n  const style = styleElement ? styleElement.textContent.trim() : '';\n  \n  // Extract script\n  const scriptElement = doc.querySelector('script');\n  let script = {};\n  \n  if (scriptElement) {\n    try {\n      // Extract the content of the script tag\n      const scriptContent = scriptElement.textContent.trim();\n      \n      // Create a function that will evaluate the script and return the exported object\n      const scriptFunction = new Function('exports', `\n        const module = { exports: {} };\n        const exportObj = {};\n        \n        // Define export default\n        function exportDefault(obj) {\n          Object.assign(exportObj, obj);\n        }\n        \n        // Execute the script\n        ${scriptContent}\n        \n        // Return the exported object\n        return exportObj;\n      `);\n      \n      // Execute the function to get the exported object\n      script = scriptFunction();\n    } catch (error) {\n      console.error(`Error parsing script: ${error.message}`);\n    }\n  }\n  \n  // Extract attributes from the root element\n  const rootElement = doc.body.firstElementChild;\n  const attributes = {};\n  \n  if (rootElement) {\n    Array.from(rootElement.attributes).forEach(attr => {\n      if (attr.name.startsWith('data-')) {\n        const propName = attr.name.replace('data-', '').replace(/-([a-z])/g, (_, letter) => letter.toUpperCase());\n        attributes[propName] = attr.value;\n      }\n    });\n  }\n  \n  return {\n    template,\n    style,\n    script,\n    attributes\n  };\n}\n","/**\n * Component Registry\n * Manages component registration and loading\n */\n\nimport { Component } from './component.js';\nimport { loadComponent, parseComponent } from './loader.js';\n\n// Store for registered components\nconst registry = new Map();\n\n/**\n * Register a component\n * @param {string} tagName - The tag name for the custom element\n * @param {Object|string} options - Component options or URL to HTML file\n * @returns {Promise<typeof Component>} - The component class\n */\nexport async function register(tagName, options) {\n  // If options is a string, treat it as a URL and load the component\n  if (typeof options === 'string') {\n    try {\n      const component = await loadComponent(options);\n      return registerComponent(tagName, component);\n    } catch (error) {\n      console.error(`Failed to register component ${tagName}: ${error.message}`);\n      throw error;\n    }\n  } else {\n    // If options is an object, register directly\n    return registerComponent(tagName, options);\n  }\n}\n\n/**\n * Register a component with the given options\n * @param {string} tagName - The tag name for the custom element\n * @param {Object} options - The component options\n * @returns {typeof Component} - The component class\n */\nfunction registerComponent(tagName, options) {\n  // Create a new component class that extends the base Component\n  class CustomComponent extends Component {}\n\n  // Add static properties\n  CustomComponent.template = options.template || '';\n  CustomComponent.styles = options.style || '';\n  CustomComponent.useShadow = options.script?.useShadow === true;\n  CustomComponent.observedAttributes = options.script?.observedAttributes || [];\n\n  // Add methods to the prototype\n  if (options.script?.methods) {\n    Object.entries(options.script.methods).forEach(([name, method]) => {\n      CustomComponent.prototype[name] = method;\n    });\n  }\n\n  // Add lifecycle hooks\n  ['init', 'connected', 'disconnected', 'attributeChanged', 'propertyChanged'].forEach(hook => {\n    if (typeof options.script?.[hook] === 'function') {\n      CustomComponent.prototype[hook] = options.script[hook];\n    }\n  });\n\n  // Add property getters and setters\n  if (options.script?.properties) {\n    Object.entries(options.script.properties).forEach(([name, config]) => {\n      // Define the property\n      Object.defineProperty(CustomComponent.prototype, name, {\n        get() {\n          return this._props[name] !== undefined ? this._props[name] : config.default;\n        },\n        set(value) {\n          const oldValue = this._props[name];\n          this._props[name] = value;\n\n          // Reflect to attribute if specified\n          if (config.reflect) {\n            const attrName = name.replace(/([A-Z])/g, '-$1').toLowerCase();\n\n            if (value === null || value === undefined) {\n              this.removeAttribute(attrName);\n            } else if (typeof value === 'boolean') {\n              if (value) {\n                this.setAttribute(attrName, '');\n              } else {\n                this.removeAttribute(attrName);\n              }\n            } else {\n              this.setAttribute(attrName, value);\n            }\n          }\n\n          // Call property changed callback if it exists\n          if (typeof this.propertyChanged === 'function' && oldValue !== value) {\n            this.propertyChanged(name, oldValue, value);\n          }\n        },\n        configurable: true,\n        enumerable: true\n      });\n\n      // Add to observed attributes if reflective\n      if (config.reflect && !CustomComponent.observedAttributes.includes(name)) {\n        const attrName = name.replace(/([A-Z])/g, '-$1').toLowerCase();\n        CustomComponent.observedAttributes.push(attrName);\n      }\n    });\n  }\n\n  // Define the custom element\n  customElements.define(tagName, CustomComponent);\n\n  // Store the component in the registry\n  registry.set(tagName, CustomComponent);\n\n  return CustomComponent;\n}\n\n/**\n * Get a registered component\n * @param {string} tagName - The tag name of the component\n * @returns {typeof Component|undefined} - The component class or undefined if not found\n */\nexport function getComponent(tagName) {\n  return registry.get(tagName);\n}\n\n/**\n * Check if a component is registered\n * @param {string} tagName - The tag name of the component\n * @returns {boolean} - Whether the component is registered\n */\nexport function hasComponent(tagName) {\n  return registry.has(tagName);\n}\n"],"names":["Component","HTMLElement","constructor","super","this","useShadow","attachShadow","mode","_props","_initialize","styles","_applyStyles","template","_applyTemplate","init","shadowRoot","styleElement","document","createElement","textContent","appendChild","scopeAttr","tagName","toLowerCase","Math","random","toString","substring","setAttribute","scopedStyles","cssRules","split","rule","trim","braceIndex","indexOf","selector","declarations","startsWith","map","s","join","head","container","innerHTML","call","_processEventBindings","allElements","querySelectorAll","Array","from","forEach","element","attributes","filter","attr","name","eventName","replace","handlerName","value","addEventListener","bind","console","warn","removeAttribute","connectedCallback","connected","disconnectedCallback","disconnected","attributeChangedCallback","oldValue","newValue","_","letter","toUpperCase","_parseAttributeValue","attributeChanged","JSON","parse","e","getElement","querySelector","getAllElements","update","props","Object","entries","key","html","strings","values","reduce","result","string","i","processedValue","isEventBinding","isArray","String","css","define","options","CustomComponent","observedAttributes","methods","method","prototype","properties","config","defineProperty","get","undefined","default","set","reflect","attrName","propertyChanged","configurable","enumerable","includes","push","customElements","async","loadComponent","url","response","fetch","ok","Error","statusText","parseComponent","text","error","message","doc","DOMParser","parseFromString","templateElement","style","scriptElement","script","scriptContent","Function","scriptFunction","rootElement","body","firstElementChild","propName","event","registry","Map","register","registerComponent","hook","getComponent","hasComponent","has"],"mappings":"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"}